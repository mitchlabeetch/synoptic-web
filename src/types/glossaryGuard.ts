// src/types/glossaryGuard.ts
// PURPOSE: Type definitions for the Glossary Guard (Personal Translation Memory) system
// ACTION: Defines term pairs, lint warnings, and glossary management structures
// MECHANISM: Enables consistent terminology enforcement across chapters and projects

/**
 * A single translation memory entry (term pair).
 * This is the core unit of the Glossary Guard system.
 */
export interface TranslationMemoryEntry {
  /** Unique identifier */
  id: string;
  
  /** The source language term (L1) */
  sourceTerm: string;
  
  /** The enforced translation (L2) */
  targetTerm: string;
  
  /** Optional: Case sensitivity for matching */
  caseSensitive: boolean;
  
  /** Optional: Match whole words only */
  wholeWord: boolean;
  
  /** Optional: Category for organization (e.g., "Characters", "Locations", "Technical") */
  category?: string;
  
  /** Optional: Notes about this term */
  notes?: string;
  
  /** Timestamp when this entry was created */
  createdAt: string;
  
  /** Timestamp when this entry was last modified */
  updatedAt: string;
}

/**
 * A lint warning generated by the Glossary Guard.
 */
export interface TermLintWarning {
  /** Unique identifier for this warning */
  id: string;
  
  /** The block ID where the warning occurs */
  blockId: string;
  
  /** The page ID where the warning occurs */
  pageId: string;
  
  /** Whether this is in L1 or L2 text */
  language: 'L1' | 'L2';
  
  /** The inconsistent term found */
  foundTerm: string;
  
  /** The expected term from the glossary */
  expectedTerm: string;
  
  /** Character offset in the text where the term was found */
  offset: number;
  
  /** Length of the found term */
  length: number;
  
  /** Severity of the warning */
  severity: 'warning' | 'error';
  
  /** The translation memory entry that triggered this warning */
  entryId: string;
}

/**
 * Categories for organizing glossary entries.
 */
export type GlossaryCategory = 
  | 'characters'       // Character names (e.g., "Harry" = "Harry")
  | 'locations'        // Place names (e.g., "Hogwarts" = "Poudlard")
  | 'technical'        // Technical terms (e.g., "Warp Drive" = "Propulseur Vitesse")
  | 'cultural'         // Cultural references
  | 'proper_nouns'     // Other proper nouns
  | 'custom';          // User-defined

/**
 * Statistics about glossary usage in a project.
 */
export interface GlossaryStats {
  /** Total number of entries */
  totalEntries: number;
  
  /** Number of entries by category */
  byCategory: Record<string, number>;
  
  /** Number of active lint warnings */
  activeWarnings: number;
  
  /** Number of times entries have been applied */
  timesApplied: number;
}

/**
 * Default categories with their display information.
 */
export const GLOSSARY_CATEGORIES: Record<GlossaryCategory, { label: string; icon: string; color: string }> = {
  characters: { label: 'Characters', icon: 'üë§', color: '#3b82f6' },
  locations: { label: 'Locations', icon: 'üìç', color: '#10b981' },
  technical: { label: 'Technical', icon: '‚öôÔ∏è', color: '#8b5cf6' },
  cultural: { label: 'Cultural', icon: 'üåç', color: '#f59e0b' },
  proper_nouns: { label: 'Proper Nouns', icon: 'üìõ', color: '#ec4899' },
  custom: { label: 'Custom', icon: 'üìù', color: '#6b7280' },
};

/**
 * Creates a new translation memory entry with defaults.
 */
export function createTranslationEntry(
  sourceTerm: string,
  targetTerm: string,
  options?: Partial<TranslationMemoryEntry>
): TranslationMemoryEntry {
  const now = new Date().toISOString();
  return {
    id: `tm-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    sourceTerm,
    targetTerm,
    caseSensitive: false,
    wholeWord: true,
    createdAt: now,
    updatedAt: now,
    ...options,
  };
}

/**
 * Checks if a text contains a term that should be flagged.
 * Returns all occurrences that don't match the expected translation.
 */
export function findInconsistentTerms(
  text: string,
  entries: TranslationMemoryEntry[],
  language: 'L1' | 'L2'
): { entry: TranslationMemoryEntry; offset: number; foundTerm: string }[] {
  const results: { entry: TranslationMemoryEntry; offset: number; foundTerm: string }[] = [];
  
  for (const entry of entries) {
    // Determine which term to look for based on which language pane we're checking
    const termToFind = language === 'L1' ? entry.sourceTerm : entry.targetTerm;
    const pattern = entry.wholeWord
      ? new RegExp(`\\b${escapeRegex(termToFind)}\\b`, entry.caseSensitive ? 'g' : 'gi')
      : new RegExp(escapeRegex(termToFind), entry.caseSensitive ? 'g' : 'gi');
    
    let match;
    while ((match = pattern.exec(text)) !== null) {
      // For L2, check if the found term matches exactly (case-sensitive check)
      if (language === 'L2' && entry.caseSensitive && match[0] !== entry.targetTerm) {
        results.push({
          entry,
          offset: match.index,
          foundTerm: match[0],
        });
      }
      // For other cases, we're just detecting presence - the main check is done elsewhere
    }
  }
  
  return results;
}

/**
 * Escapes special regex characters in a string.
 */
function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Finds all term violations in text content and generates lint warnings.
 * This is the main linting function used by the Glossary Guard system.
 */
export function findTermViolations(
  text: string,
  entries: TranslationMemoryEntry[],
  blockId: string,
  pageId: string,
  language: 'L1' | 'L2'
): TermLintWarning[] {
  const warnings: TermLintWarning[] = [];
  const normalizedText = text.toLowerCase();
  
  for (const entry of entries) {
    // In L1 pane, we look for alternates of the SOURCE term that should be standardized
    // In L2 pane, we look for uses of the SOURCE term that should be the TARGET term
    
    if (language === 'L2') {
      // In L2 pane: Check if source term is used (it should be the target term)
      const sourceTerm = entry.sourceTerm;
      const pattern = entry.wholeWord
        ? new RegExp(`\\b${escapeRegex(sourceTerm)}\\b`, entry.caseSensitive ? 'g' : 'gi')
        : new RegExp(escapeRegex(sourceTerm), entry.caseSensitive ? 'g' : 'gi');
      
      let match;
      while ((match = pattern.exec(text)) !== null) {
        // Found source term in L2 text - should be target term
        warnings.push({
          id: `warn-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          blockId,
          pageId,
          language,
          foundTerm: match[0],
          expectedTerm: entry.targetTerm,
          offset: match.index,
          length: match[0].length,
          severity: 'warning',
          entryId: entry.id,
        });
      }
    } else {
      // In L1 pane: Check if target term is used (it should be the source term)
      const targetTerm = entry.targetTerm;
      const pattern = entry.wholeWord
        ? new RegExp(`\\b${escapeRegex(targetTerm)}\\b`, entry.caseSensitive ? 'g' : 'gi')
        : new RegExp(escapeRegex(targetTerm), entry.caseSensitive ? 'g' : 'gi');
      
      let match;
      while ((match = pattern.exec(text)) !== null) {
        // Found target term in L1 text - should be source term
        warnings.push({
          id: `warn-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          blockId,
          pageId,
          language,
          foundTerm: match[0],
          expectedTerm: entry.sourceTerm,
          offset: match.index,
          length: match[0].length,
          severity: 'warning',
          entryId: entry.id,
        });
      }
    }
  }
  
  return warnings;
}
